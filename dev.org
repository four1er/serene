* Parser
First of all you need to read [[https://tomassetti.me/guide-parsing-algorithms-terminology/][All you need to know about Parser algorithms]].
Then here is the list or parsers that we have considered
- Rust parser combinator framework :: https://github.com/Geal/nom/
- LR(1) parser generator for Rust :: https://github.com/lalrpop/lalrpop
- A parser combinator library for Rust :: https://github.com/Marwes/combine
- Parsing Expression Grammar (PEG) parser generator for Rust :: https://github.com/kevinmehall/rust-peg
- General purpose parser :: https://pest.rs/
* Considerations
** Hashmaps
*** DOS attack
- https://www.anchor.com.au/blog/2012/12/how-to-explain-hash-dos-to-your-parents-by-using-cats/
- https://en.wikipedia.org/wiki/Collision_attack

* Resources
** Rust
- The Rust book :: https://doc.rust-lang.org/book/ https://www.reddit.com/r/rust/comments/2s1zj2/the_rust_programming_language_book_as_epub/
** LLVM
- Brief overview of LLVM :: https://www.infoworld.com/article/3247799/what-is-llvm-the-power-behind-swift-rust-clang-and-more.html
- A bit in depth details on LLVM :: https://aosabook.org/en/llvm.html
- Rust binding :: https://crates.io/crates/llvm-sys
- Official LLVM tutorial C++ :: https://llvm.org/docs/tutorial/
- Rust LLVM tutorial :: https://github.com/jauhien/iron-kaleidoscope

** Data structures
- Pure functional datastructures papaer :: https://www.cs.cmu.edu/~rwh/theses/okasaki.pdf
- Dynamic typing: syntax and proof theory :: https://reader.elsevier.com/reader/sd/pii/0167642394000042?token=CEFF5C5D1B03FD680762FC4889A14C0CA2BB28FE390EC51099984536E12AC358F3D28A5C25C274296ACBBC32E5AE23CD
- Representing Type Information in Dynamically Typed Languages :: https://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.39.4394
- An empirical study on the impact of static typing on software maintainability :: https://www.researchgate.net/publication/259634489_An_empirical_study_on_the_impact_of_static_typing_on_software_maintainability

** Other languages
- Julia: A Fresh Approach toNumerical Computing :: https://julialang.org/research/julia-fresh-approach-BEKS.pdf
** Cranelift
- Source tree :: https://github.com/bytecodealliance/wasmtime/tree/master/cranelift

* Possible solutions
** Garbage collection
- https://v8.dev/blog/high-performance-cpp-gc
** JIT
- https://asmjit.com/
* Features to implement
** Compiler
*** Branch instructions
It would be cool to have macro to instruct the compiler about the likelyhood
of a branch in a conditional. Something similar to kernel's *likely* and *unlikely*
macros
*** Execution Instrumentation
The compiler should be able to embed some code in the program to collect data about
the different execution paths or function instrumentation and other useful data the
can help the compiler to optimize the program even further. For example Imagine a
scenario which we compile a program with out any optimization ( in debug mode ) and
using some test cases or real usage of the program in several iteration we collect
data about the compiled application in a file (let's call it the ADF short for Analytic
Data File), and the we can pass that ADF file to the compiler to let it compile and optimize
the program by using the usual passes alonge side with some extra passes that operate
on ADF
** Lang
