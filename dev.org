* Serene's Development Resources
This document is dedicated to collecting useful resources to help us in the development process.
Any thing that might be useful, tools, other languages to look at, inspirations literally anything. Just
try to find the best heading for them. IF your not familiar with the org mode markup checkout
[[https://emacsclub.github.io/html/org_tutorial.html#sec-7][this cheatsheet]].

* Parser
First of all you need to read [[https://tomassetti.me/guide-parsing-algorithms-terminology/][All you need to know about Parser algorithms]].
Then here is the list or parsers that we have considered
- Rust parser combinator framework :: https://github.com/Geal/nom/
- LR(1) parser generator for Rust :: https://github.com/lalrpop/lalrpop
- A parser combinator library for Rust :: https://github.com/Marwes/combine
- Parsing Expression Grammar (PEG) parser generator for Rust :: https://github.com/kevinmehall/rust-peg
- General purpose parser :: https://pest.rs/
* Considerations
** Hashmaps
*** DOS attack
- https://www.anchor.com.au/blog/2012/12/how-to-explain-hash-dos-to-your-parents-by-using-cats/
- https://en.wikipedia.org/wiki/Collision_attack

* Resources
For a generic list of resources on compiler design take a look at https://tomassetti.me/resources-create-programming-languages/
https://www.reddit.com/r/ProgrammingLanguages/comments/8ggx2n/is_llvm_a_good_backend_for_functional_languages/
** Lisp
- Make a Lisp :: https://github.com/kanaka/mal/blob/master/process/guide.md
*** Quasiquotation
- Backquote in CL :: http://www.lispworks.com/documentation/HyperSpec/Body/02_df.htm
- Backquote spec in Common Lisp the Language, 2nd Edition :: https://www.cs.cmu.edu/Groups/AI/html/cltl/clm/node367.html
- Backquote and pretty printing :: http://christophe.rhodes.io/notes/blog/posts/2014/backquote_and_pretty_printing/
** Rust
- The Rust book :: https://doc.rust-lang.org/book/ https://www.reddit.com/r/rust/comments/2s1zj2/the_rust_programming_language_book_as_epub/
** LLVM
- Brief overview of LLVM :: https://www.infoworld.com/article/3247799/what-is-llvm-the-power-behind-swift-rust-clang-and-more.html
- A bit in depth details on LLVM :: https://aosabook.org/en/llvm.html
- Official LLVM tutorial C++ :: https://llvm.org/docs/tutorial/
- Interactive C++ with Cling :: https://blog.llvm.org/posts/2020-11-30-interactive-cpp-with-cling/
** Data structures
- Pure functional datastructures papaer :: https://www.cs.cmu.edu/~rwh/theses/okasaki.pdf
- Dynamic typing: syntax and proof theory :: https://reader.elsevier.com/reader/sd/pii/0167642394000042?token=CEFF5C5D1B03FD680762FC4889A14C0CA2BB28FE390EC51099984536E12AC358F3D28A5C25C274296ACBBC32E5AE23CD
- Representing Type Information in Dynamically Typed Languages :: https://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.39.4394
- An empirical study on the impact of static typing on software maintainability :: https://www.researchgate.net/publication/259634489_An_empirical_study_on_the_impact_of_static_typing_on_software_maintainability

** Other languages
- Julia: A Fresh Approach toNumerical Computing :: https://julialang.org/research/julia-fresh-approach-BEKS.pdf
** Cranelift
- Source tree :: https://github.com/bytecodealliance/wasmtime/tree/master/cranelift
** Memory management
- Visualizing memory management in Golang :: https://deepu.tech/memory-management-in-golang/
- TCMalloc : Thread-Caching Malloc :: http://goog-perftools.sourceforge.net/doc/tcmalloc.html
- A visual guide to Go Memory Allocator from scratch (Golang) :: https://medium.com/@ankur_anand/a-visual-guide-to-golang-memory-allocator-from-ground-up-e132258453ed
** Concurrency
- Scheduling In Go (Series) :: https://www.ardanlabs.com/blog/2018/08/scheduling-in-go-part1.html

** Garbage collection
- https://v8.dev/blog/high-performance-cpp-gc
- Perceus: Garbage Free Reference Counting with Reuse :: https://www.microsoft.com/en-us/research/uploads/prod/2020/11/perceus-tr-v1.pdf
** JIT
- https://asmjit.com/
** Compiler
- Stack frame layout on x86-64 :: https://eli.thegreenplace.net/2011/09/06/stack-frame-layout-on-x86-64
*** Branch instructions
It would be cool to have macro to instruct the compiler about the likelyhood
of a branch in a conditional. Something similar to kernel's *likely* and *unlikely*
macros
*** Execution Instrumentation
The compiler should be able to embed some code in the program to collect data about
the different execution paths or function instrumentation and other useful data the
can help the compiler to optimize the program even further. For example Imagine a
scenario which we compile a program with out any optimization ( in debug mode ) and
using some test cases or real usage of the program in several iteration we collect
data about the compiled application in a file (let's call it the ADF short for Analytic
Data File), and the we can pass that ADF file to the compiler to let it compile and optimize
the program by using the usual passes alonge side with some extra passes that operate
on ADF
** Lang
*** Scheme
- Chicken Scheme - Easy-to-use compiler and interpreter, with lots of libraries :: https://call-cc.org
- Stalin - Brutally optimizing Scheme compiler, with lots of optimization flags :: https://github.com/barak/stalin
* TODOs
** Bootstrap
*** TODO Language Spec
*** TODO A proper List implementation
    It should be a proper linked list
*** TODO Vector implementation
*** TODO Hashmap implementation
*** TODO Call stack
- [ ] Thread local call stack
- [ ] Handle TCO in the call stack
- [ ] Integration with the Error handling
*** TODO Meta data support
- [ ] Attachable meta data to any expression
- [ ] Spec for special meta data that mean something to the interpreter. E.g: docstrings
- [ ] Meta data API
*** TODO Docstring support
- [ ] For functions and macros
- [ ] For namespaces and projects
- [ ] API to interact with docstrings and helps
*** TODO FFI interface
- [ ] Convertion of Serene types to C types
- [ ] Shared libraries dynamic loading
- [ ] Integration with namespaces and requirement set
- [ ] Necessary API and checks for library and ABI Availability
*** TODO Load path and namespace loading
*** TODO nREPL
*** TODO Emacs mode
*** TODO Number implementation
- [ ] Basic operations
- [ ] Standard functions in Serene itself
- [ ] Type infer and conversion
*** TODO String implementation
- [ ] Basic operations
- [ ] Numer <-> String
- [ ] Interpolation
*** TODO Enum implementation
- [ ] Embedded data in a variant
- [ ] Generate functions based on variants
*** TODO Protocol
- [ ] Polymorphic functions
*** TODO Struct implementation
*** TODO Error handling
- [ ] Integration with callstacks
- [ ] Stackable errors
*** TODO Multi arity functions
*** TODO QuasiQuotation
*** TODO Linter
*** TODO Document generator
*** TODO Spec like functionality
*** TODO Laziness implementation
*** Standard libraries
**** TODO IO library
**** TODO Test library
